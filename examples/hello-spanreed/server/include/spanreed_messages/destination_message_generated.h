// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DESTINATIONMESSAGE_SPANREEDMESSAGE_H_
#define FLATBUFFERS_GENERATED_DESTINATIONMESSAGE_SPANREEDMESSAGE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace SpanreedMessage {

struct ProxyMessage;
struct ProxyMessageBuilder;

struct ConnectionVerdict;
struct ConnectionVerdictBuilder;

struct CloseConnection;
struct CloseConnectionBuilder;

struct DestinationMessage;
struct DestinationMessageBuilder;

enum InnerMsg : uint8_t {
  InnerMsg_NONE = 0,
  InnerMsg_ProxyMessage = 1,
  InnerMsg_ConnectionVerdict = 2,
  InnerMsg_CloseConnection = 3,
  InnerMsg_MIN = InnerMsg_NONE,
  InnerMsg_MAX = InnerMsg_CloseConnection
};

inline const InnerMsg (&EnumValuesInnerMsg())[4] {
  static const InnerMsg values[] = {
    InnerMsg_NONE,
    InnerMsg_ProxyMessage,
    InnerMsg_ConnectionVerdict,
    InnerMsg_CloseConnection
  };
  return values;
}

inline const char * const *EnumNamesInnerMsg() {
  static const char * const names[5] = {
    "NONE",
    "ProxyMessage",
    "ConnectionVerdict",
    "CloseConnection",
    nullptr
  };
  return names;
}

inline const char *EnumNameInnerMsg(InnerMsg e) {
  if (::flatbuffers::IsOutRange(e, InnerMsg_NONE, InnerMsg_CloseConnection)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesInnerMsg()[index];
}

template<typename T> struct InnerMsgTraits {
  static const InnerMsg enum_value = InnerMsg_NONE;
};

template<> struct InnerMsgTraits<SpanreedMessage::ProxyMessage> {
  static const InnerMsg enum_value = InnerMsg_ProxyMessage;
};

template<> struct InnerMsgTraits<SpanreedMessage::ConnectionVerdict> {
  static const InnerMsg enum_value = InnerMsg_ConnectionVerdict;
};

template<> struct InnerMsgTraits<SpanreedMessage::CloseConnection> {
  static const InnerMsg enum_value = InnerMsg_CloseConnection;
};

bool VerifyInnerMsg(::flatbuffers::Verifier &verifier, const void *obj, InnerMsg type);
bool VerifyInnerMsgVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct ProxyMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProxyMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLIENT_ID = 4
  };
  uint32_t client_id() const {
    return GetField<uint32_t>(VT_CLIENT_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CLIENT_ID, 4) &&
           verifier.EndTable();
  }
};

struct ProxyMessageBuilder {
  typedef ProxyMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_client_id(uint32_t client_id) {
    fbb_.AddElement<uint32_t>(ProxyMessage::VT_CLIENT_ID, client_id, 0);
  }
  explicit ProxyMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ProxyMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ProxyMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ProxyMessage> CreateProxyMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t client_id = 0) {
  ProxyMessageBuilder builder_(_fbb);
  builder_.add_client_id(client_id);
  return builder_.Finish();
}

struct ConnectionVerdict FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConnectionVerdictBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLIENT_ID = 4,
    VT_ACCEPTED = 6
  };
  uint32_t client_id() const {
    return GetField<uint32_t>(VT_CLIENT_ID, 0);
  }
  bool accepted() const {
    return GetField<uint8_t>(VT_ACCEPTED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CLIENT_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_ACCEPTED, 1) &&
           verifier.EndTable();
  }
};

struct ConnectionVerdictBuilder {
  typedef ConnectionVerdict Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_client_id(uint32_t client_id) {
    fbb_.AddElement<uint32_t>(ConnectionVerdict::VT_CLIENT_ID, client_id, 0);
  }
  void add_accepted(bool accepted) {
    fbb_.AddElement<uint8_t>(ConnectionVerdict::VT_ACCEPTED, static_cast<uint8_t>(accepted), 0);
  }
  explicit ConnectionVerdictBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConnectionVerdict> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConnectionVerdict>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConnectionVerdict> CreateConnectionVerdict(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t client_id = 0,
    bool accepted = false) {
  ConnectionVerdictBuilder builder_(_fbb);
  builder_.add_client_id(client_id);
  builder_.add_accepted(accepted);
  return builder_.Finish();
}

struct CloseConnection FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CloseConnectionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLIENT_ID = 4,
    VT_REASON = 6
  };
  uint32_t client_id() const {
    return GetField<uint32_t>(VT_CLIENT_ID, 0);
  }
  const ::flatbuffers::String *reason() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REASON);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CLIENT_ID, 4) &&
           VerifyOffset(verifier, VT_REASON) &&
           verifier.VerifyString(reason()) &&
           verifier.EndTable();
  }
};

struct CloseConnectionBuilder {
  typedef CloseConnection Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_client_id(uint32_t client_id) {
    fbb_.AddElement<uint32_t>(CloseConnection::VT_CLIENT_ID, client_id, 0);
  }
  void add_reason(::flatbuffers::Offset<::flatbuffers::String> reason) {
    fbb_.AddOffset(CloseConnection::VT_REASON, reason);
  }
  explicit CloseConnectionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CloseConnection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CloseConnection>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CloseConnection> CreateCloseConnection(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t client_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> reason = 0) {
  CloseConnectionBuilder builder_(_fbb);
  builder_.add_reason(reason);
  builder_.add_client_id(client_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CloseConnection> CreateCloseConnectionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t client_id = 0,
    const char *reason = nullptr) {
  auto reason__ = reason ? _fbb.CreateString(reason) : 0;
  return SpanreedMessage::CreateCloseConnection(
      _fbb,
      client_id,
      reason__);
}

struct DestinationMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DestinationMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MSG_TYPE = 4,
    VT_MSG = 6,
    VT_APP_DATA = 8
  };
  SpanreedMessage::InnerMsg msg_type() const {
    return static_cast<SpanreedMessage::InnerMsg>(GetField<uint8_t>(VT_MSG_TYPE, 0));
  }
  const void *msg() const {
    return GetPointer<const void *>(VT_MSG);
  }
  template<typename T> const T *msg_as() const;
  const SpanreedMessage::ProxyMessage *msg_as_ProxyMessage() const {
    return msg_type() == SpanreedMessage::InnerMsg_ProxyMessage ? static_cast<const SpanreedMessage::ProxyMessage *>(msg()) : nullptr;
  }
  const SpanreedMessage::ConnectionVerdict *msg_as_ConnectionVerdict() const {
    return msg_type() == SpanreedMessage::InnerMsg_ConnectionVerdict ? static_cast<const SpanreedMessage::ConnectionVerdict *>(msg()) : nullptr;
  }
  const SpanreedMessage::CloseConnection *msg_as_CloseConnection() const {
    return msg_type() == SpanreedMessage::InnerMsg_CloseConnection ? static_cast<const SpanreedMessage::CloseConnection *>(msg()) : nullptr;
  }
  const ::flatbuffers::Vector<uint8_t> *app_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_APP_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE, 1) &&
           VerifyOffset(verifier, VT_MSG) &&
           VerifyInnerMsg(verifier, msg(), msg_type()) &&
           VerifyOffset(verifier, VT_APP_DATA) &&
           verifier.VerifyVector(app_data()) &&
           verifier.EndTable();
  }
};

template<> inline const SpanreedMessage::ProxyMessage *DestinationMessage::msg_as<SpanreedMessage::ProxyMessage>() const {
  return msg_as_ProxyMessage();
}

template<> inline const SpanreedMessage::ConnectionVerdict *DestinationMessage::msg_as<SpanreedMessage::ConnectionVerdict>() const {
  return msg_as_ConnectionVerdict();
}

template<> inline const SpanreedMessage::CloseConnection *DestinationMessage::msg_as<SpanreedMessage::CloseConnection>() const {
  return msg_as_CloseConnection();
}

struct DestinationMessageBuilder {
  typedef DestinationMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_msg_type(SpanreedMessage::InnerMsg msg_type) {
    fbb_.AddElement<uint8_t>(DestinationMessage::VT_MSG_TYPE, static_cast<uint8_t>(msg_type), 0);
  }
  void add_msg(::flatbuffers::Offset<void> msg) {
    fbb_.AddOffset(DestinationMessage::VT_MSG, msg);
  }
  void add_app_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> app_data) {
    fbb_.AddOffset(DestinationMessage::VT_APP_DATA, app_data);
  }
  explicit DestinationMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DestinationMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DestinationMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DestinationMessage> CreateDestinationMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    SpanreedMessage::InnerMsg msg_type = SpanreedMessage::InnerMsg_NONE,
    ::flatbuffers::Offset<void> msg = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> app_data = 0) {
  DestinationMessageBuilder builder_(_fbb);
  builder_.add_app_data(app_data);
  builder_.add_msg(msg);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DestinationMessage> CreateDestinationMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    SpanreedMessage::InnerMsg msg_type = SpanreedMessage::InnerMsg_NONE,
    ::flatbuffers::Offset<void> msg = 0,
    const std::vector<uint8_t> *app_data = nullptr) {
  auto app_data__ = app_data ? _fbb.CreateVector<uint8_t>(*app_data) : 0;
  return SpanreedMessage::CreateDestinationMessage(
      _fbb,
      msg_type,
      msg,
      app_data__);
}

inline bool VerifyInnerMsg(::flatbuffers::Verifier &verifier, const void *obj, InnerMsg type) {
  switch (type) {
    case InnerMsg_NONE: {
      return true;
    }
    case InnerMsg_ProxyMessage: {
      auto ptr = reinterpret_cast<const SpanreedMessage::ProxyMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InnerMsg_ConnectionVerdict: {
      auto ptr = reinterpret_cast<const SpanreedMessage::ConnectionVerdict *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InnerMsg_CloseConnection: {
      auto ptr = reinterpret_cast<const SpanreedMessage::CloseConnection *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyInnerMsgVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyInnerMsg(
        verifier,  values->Get(i), types->GetEnum<InnerMsg>(i))) {
      return false;
    }
  }
  return true;
}

inline const SpanreedMessage::DestinationMessage *GetDestinationMessage(const void *buf) {
  return ::flatbuffers::GetRoot<SpanreedMessage::DestinationMessage>(buf);
}

inline const SpanreedMessage::DestinationMessage *GetSizePrefixedDestinationMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<SpanreedMessage::DestinationMessage>(buf);
}

inline bool VerifyDestinationMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SpanreedMessage::DestinationMessage>(nullptr);
}

inline bool VerifySizePrefixedDestinationMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<SpanreedMessage::DestinationMessage>(nullptr);
}

inline void FinishDestinationMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<SpanreedMessage::DestinationMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedDestinationMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<SpanreedMessage::DestinationMessage> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace SpanreedMessage

#endif  // FLATBUFFERS_GENERATED_DESTINATIONMESSAGE_SPANREEDMESSAGE_H_
