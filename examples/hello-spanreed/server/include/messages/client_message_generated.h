// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CLIENTMESSAGE_HELLOSPANREED_H_
#define FLATBUFFERS_GENERATED_CLIENTMESSAGE_HELLOSPANREED_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace HelloSpanreed {

struct UserConnectMessage;
struct UserConnectMessageBuilder;

struct UserClickMessage;
struct UserClickMessageBuilder;

struct UserChatMessage;
struct UserChatMessageBuilder;

struct ClientMessage;
struct ClientMessageBuilder;

enum UserMessage : uint8_t {
  UserMessage_NONE = 0,
  UserMessage_UserConnectMessage = 1,
  UserMessage_UserClickMessage = 2,
  UserMessage_UserChatMessage = 3,
  UserMessage_MIN = UserMessage_NONE,
  UserMessage_MAX = UserMessage_UserChatMessage
};

inline const UserMessage (&EnumValuesUserMessage())[4] {
  static const UserMessage values[] = {
    UserMessage_NONE,
    UserMessage_UserConnectMessage,
    UserMessage_UserClickMessage,
    UserMessage_UserChatMessage
  };
  return values;
}

inline const char * const *EnumNamesUserMessage() {
  static const char * const names[5] = {
    "NONE",
    "UserConnectMessage",
    "UserClickMessage",
    "UserChatMessage",
    nullptr
  };
  return names;
}

inline const char *EnumNameUserMessage(UserMessage e) {
  if (::flatbuffers::IsOutRange(e, UserMessage_NONE, UserMessage_UserChatMessage)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUserMessage()[index];
}

template<typename T> struct UserMessageTraits {
  static const UserMessage enum_value = UserMessage_NONE;
};

template<> struct UserMessageTraits<HelloSpanreed::UserConnectMessage> {
  static const UserMessage enum_value = UserMessage_UserConnectMessage;
};

template<> struct UserMessageTraits<HelloSpanreed::UserClickMessage> {
  static const UserMessage enum_value = UserMessage_UserClickMessage;
};

template<> struct UserMessageTraits<HelloSpanreed::UserChatMessage> {
  static const UserMessage enum_value = UserMessage_UserChatMessage;
};

bool VerifyUserMessage(::flatbuffers::Verifier &verifier, const void *obj, UserMessage type);
bool VerifyUserMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct UserConnectMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UserConnectMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct UserConnectMessageBuilder {
  typedef UserConnectMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(UserConnectMessage::VT_NAME, name);
  }
  explicit UserConnectMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UserConnectMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UserConnectMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UserConnectMessage> CreateUserConnectMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  UserConnectMessageBuilder builder_(_fbb);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UserConnectMessage> CreateUserConnectMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return HelloSpanreed::CreateUserConnectMessage(
      _fbb,
      name__);
}

struct UserClickMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UserClickMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6
  };
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           verifier.EndTable();
  }
};

struct UserClickMessageBuilder {
  typedef UserClickMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(float x) {
    fbb_.AddElement<float>(UserClickMessage::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(UserClickMessage::VT_Y, y, 0.0f);
  }
  explicit UserClickMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UserClickMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UserClickMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UserClickMessage> CreateUserClickMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f) {
  UserClickMessageBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct UserChatMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UserChatMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT = 4
  };
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           verifier.EndTable();
  }
};

struct UserChatMessageBuilder {
  typedef UserChatMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(UserChatMessage::VT_TEXT, text);
  }
  explicit UserChatMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UserChatMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UserChatMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UserChatMessage> CreateUserChatMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0) {
  UserChatMessageBuilder builder_(_fbb);
  builder_.add_text(text);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UserChatMessage> CreateUserChatMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return HelloSpanreed::CreateUserChatMessage(
      _fbb,
      text__);
}

struct ClientMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ClientMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USER_MESSAGE_TYPE = 4,
    VT_USER_MESSAGE = 6
  };
  HelloSpanreed::UserMessage user_message_type() const {
    return static_cast<HelloSpanreed::UserMessage>(GetField<uint8_t>(VT_USER_MESSAGE_TYPE, 0));
  }
  const void *user_message() const {
    return GetPointer<const void *>(VT_USER_MESSAGE);
  }
  template<typename T> const T *user_message_as() const;
  const HelloSpanreed::UserConnectMessage *user_message_as_UserConnectMessage() const {
    return user_message_type() == HelloSpanreed::UserMessage_UserConnectMessage ? static_cast<const HelloSpanreed::UserConnectMessage *>(user_message()) : nullptr;
  }
  const HelloSpanreed::UserClickMessage *user_message_as_UserClickMessage() const {
    return user_message_type() == HelloSpanreed::UserMessage_UserClickMessage ? static_cast<const HelloSpanreed::UserClickMessage *>(user_message()) : nullptr;
  }
  const HelloSpanreed::UserChatMessage *user_message_as_UserChatMessage() const {
    return user_message_type() == HelloSpanreed::UserMessage_UserChatMessage ? static_cast<const HelloSpanreed::UserChatMessage *>(user_message()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_USER_MESSAGE_TYPE, 1) &&
           VerifyOffset(verifier, VT_USER_MESSAGE) &&
           VerifyUserMessage(verifier, user_message(), user_message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const HelloSpanreed::UserConnectMessage *ClientMessage::user_message_as<HelloSpanreed::UserConnectMessage>() const {
  return user_message_as_UserConnectMessage();
}

template<> inline const HelloSpanreed::UserClickMessage *ClientMessage::user_message_as<HelloSpanreed::UserClickMessage>() const {
  return user_message_as_UserClickMessage();
}

template<> inline const HelloSpanreed::UserChatMessage *ClientMessage::user_message_as<HelloSpanreed::UserChatMessage>() const {
  return user_message_as_UserChatMessage();
}

struct ClientMessageBuilder {
  typedef ClientMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_user_message_type(HelloSpanreed::UserMessage user_message_type) {
    fbb_.AddElement<uint8_t>(ClientMessage::VT_USER_MESSAGE_TYPE, static_cast<uint8_t>(user_message_type), 0);
  }
  void add_user_message(::flatbuffers::Offset<void> user_message) {
    fbb_.AddOffset(ClientMessage::VT_USER_MESSAGE, user_message);
  }
  explicit ClientMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ClientMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ClientMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ClientMessage> CreateClientMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    HelloSpanreed::UserMessage user_message_type = HelloSpanreed::UserMessage_NONE,
    ::flatbuffers::Offset<void> user_message = 0) {
  ClientMessageBuilder builder_(_fbb);
  builder_.add_user_message(user_message);
  builder_.add_user_message_type(user_message_type);
  return builder_.Finish();
}

inline bool VerifyUserMessage(::flatbuffers::Verifier &verifier, const void *obj, UserMessage type) {
  switch (type) {
    case UserMessage_NONE: {
      return true;
    }
    case UserMessage_UserConnectMessage: {
      auto ptr = reinterpret_cast<const HelloSpanreed::UserConnectMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserMessage_UserClickMessage: {
      auto ptr = reinterpret_cast<const HelloSpanreed::UserClickMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UserMessage_UserChatMessage: {
      auto ptr = reinterpret_cast<const HelloSpanreed::UserChatMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyUserMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyUserMessage(
        verifier,  values->Get(i), types->GetEnum<UserMessage>(i))) {
      return false;
    }
  }
  return true;
}

inline const HelloSpanreed::ClientMessage *GetClientMessage(const void *buf) {
  return ::flatbuffers::GetRoot<HelloSpanreed::ClientMessage>(buf);
}

inline const HelloSpanreed::ClientMessage *GetSizePrefixedClientMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<HelloSpanreed::ClientMessage>(buf);
}

inline bool VerifyClientMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<HelloSpanreed::ClientMessage>(nullptr);
}

inline bool VerifySizePrefixedClientMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<HelloSpanreed::ClientMessage>(nullptr);
}

inline void FinishClientMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<HelloSpanreed::ClientMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedClientMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<HelloSpanreed::ClientMessage> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace HelloSpanreed

#endif  // FLATBUFFERS_GENERATED_CLIENTMESSAGE_HELLOSPANREED_H_
